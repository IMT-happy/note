ES6 的学习总结：
结构赋值大法：
const {} = obj || {} // 这样写的好处是避免obj为null 或者 undefined 带来的语法错误。
const { a:a1} =obj || {} // 这样的写法，是从obj对象中取出值重命名成需要的。

new Set() 如果处理数组的话，可以作为去重使用

字符串模板：
${} 中可以写表达式：`${name}${score > 60?'的考试成绩及格':'的考试成绩不及格'}`;

判读语句：
如果需要多重判断，可以使用数组.includes() 来做
eg：
if(item == 1 || item == 2){} =====> const test = [1,2]; if(test.includes(item)){}

数组过滤：
.filter() 可以return 符合条件的数据出来，如何优化性能，可以用find关键字。即：.filter ==> .find （优化的点再去，filter会便利一边数组，但是find，找到符合的条件就不再便利了）仅用于精确筛选，如果是数组筛选，还是需要用filter的，find 搜索到就return 出来了

数组处理：
多级数组的扁平化处理：将多维数组都扁平到一级数组中，flat
object.values(obj).flat(infinity)

对于输入条件的判断：
if(a!==null && a!==undifined && a!== ''){} ===> if((a??'') !== ''){} 

解构赋值 是允许在解构的时候，带上自己的默认值的 

嵌套赋值 (活学活用)：
({foo:obj.prop,bar:arr[0]} = {foo:123,bar:true}); obj:{prop:123},bar:[true] 

解构赋值写法注意：
let [x,y] = [1,2] ---> right
let x,y
{x,y} = {1,2} ---> error

{} 这个会被当作是一个代码块来解析，就不会被解构赋值到。如果需要让其执行，需要在最外层加一个括号，可视为独立的代码结构

对象可以解构数组，数组是特殊的对象。

字符串的解构赋值如果是数组形态，就是将字符串拆分成一个个字符，如果左边是对象则是找字符串的属性

[a,b,c] = 'abc'; a=a;b=b,c=c; {length : len} = 'abc'; len=3

解构赋值的规则，右边的值，不是对象或数组，就先将其转为对象。

函数参数的解构赋值 其实寻找的是入参里面的值。fun([a;2,b:3]){ return a + b} // 其中会自行解开这两个入参

解构赋值中的等号，永远是做默认值的处理。

for(let xxx of xxxx) 这里的xxx 只会是 xxxx里的某个元素；不论xxxx 是什么类型(数组，字符串，数组对象)。统一理解：就是这样的形式，要适用于存在iterable 属性的元素。

函数的参数如果是个对象，为了避免是个空对象而带来错误可以这样处理 func({x,y=2}={}){} 就是给参数的整体追加一个默认值。

undefined，可以触发默认值，但是null 不可以。

func 实例的长度是参数的个数，但是参数有默认值的话，是不计算其长度的 // 这个没什么具体的作用，当了解吧

rest 参数，作为函数入参，只能是最后一位，之后不可再跟参数，否则会报错。

数组的map，return 之后，会得到处理过后的新数组

尾调用的优势在于，避免栈溢出，多引用。（调用栈太多导致）

rest+字符串 == 字符串.split('') // 这个没有用到过，需要记一下 // 需要记住的：如果是对象对字符串rest，那么就是index为key，值为value的对象集合。如果是数组对字符串rest后的容器，则是数组中的一个个值。

Arrayfrom 方法讲两类对象转为真正的数组，一个是类似数组的对象，一个是拥有iterable 属性的对象。 可以接受一个函数作为第二个参数，作用类似于数组的map() 
array.from([1,2,3],(x)=> x*x) ===> array.from([1,2,3]).map( x=> x*x)
 
Array.of() 将一组数值转换成数组。总是这样。

数组的entries values keys 分别是检索数组的 key value，以及整个数组

flat 扁平化数组的方法。嵌套层级可以通过 infinity 进行参数校准

返回对象中 如果对象的key 存在对应的value，那便可以直接在对象中写入key的关键字即可。
a=1;b=2 const obj={a,b} == obj={a:1,b:2} // 组成完整的对象

rest 参数化，其实就是将对象，或者数组中的值便利取出来，丢到一个新的存储容器中，这个存储容器可以是另一个新的对象，或者是数组。s

Object.fromEntries 是 Object.emtries 的逆向操作，对象的entries 是将key value，扁平化到一级数组中，fromEntries。则是根据这个被扁平话的数组解构进行对象的重构，

运算符：

指数运算：（指数运算连用的时候，是先处理右边的运算条件）
2 ** 2 == 2 的 2 次方
2 ** 3 == 2 的 3 次方

// **2 === **= 2 

set  // 结构是去重，这个只是set结构的数组，但是需要转换成实际的数组，需要rest处理，或者 Array.from() 处理

结构中的 keys 遍历和values 遍历都是一样的操作效果，因为这两个值一样。

数组如果使用新的set结构进行重新处理，new Set() 则会进行新的数据结构处理。





















